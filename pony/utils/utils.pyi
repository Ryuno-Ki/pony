from pony import options
from pony.py23compat import (
    PY2,
    basestring,
    imap,
    iteritems,
    pickle,  # type: ignore
    unicode
)
from pony.thirdparty.compiler import ast
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    NoReturn,
    Optional,
    Pattern,
    Tuple,
    Union
)

localbase = Union[object, Any]  # TODO: Any should be threading.local

class PonyDeprecationWarning(DeprecationWarning): ...

def deprecated(stacklevel: int, message: str) -> None: ...
def decorator(caller: Any, func: Optional[Callable] = ...): ...
def decorator_with_params(dec: Callable): ...
def cut_traceback(func: Callable, *args: Any, **kwargs: Any): ...

cut_traceback_depth: int

def reraise(exc_type: Any, exc: Any, tb: Any) -> None: ...
def throw(exc_type: Any, *args: Any, **kwargs: Any) -> None: ...
def truncate_repr(s: str, max_len: int = ...): ...

codeobjects: Dict[int, Any]

def get_codeobject_id(codeobject: Any) -> int: ...

lambda_args_cache: Dict[int, str]

def get_lambda_args(func: Callable): ...
def error_method(*args: Any, **kwargs: Any) -> NoReturn: ...
def is_ident(string: str) -> bool: ...
def split_name(name: str) -> Union[List[str], NoReturn]: ...
def uppercase_name(name: str) -> str: ...
def lowercase_name(name: str) -> str: ...
def camelcase_name(name: str) -> str: ...
def mixedcase_name(name: str) -> str: ...
def import_module(name: str) -> Any: ...
def is_absolute_path(filename: str) -> bool: ...
def absolutize_path(filename: str, frame_depth: int) -> Union[str, NoReturn]: ...
def current_timestamp() -> str: ...
def datetime2timestamp(d: Any) -> str: ...  # TODO: should be datetime
def timestamp2datetime(t: str) -> Any: ...  # TODO: should be datetime

expr1_re: Pattern
expr2_re: Pattern
expr3_re: Pattern

def parse_expr(s: str, pos: int = ...) -> Tuple[str, bool]: ...
def tostring(x: Any) -> str: ...
def strjoin(sep: str, strings: Iterable, source_encoding: str = ..., dest_encoding: Optional[str] = ...): ...
def count(*args: Any, **kwargs: Any) -> int: ...
def avg(iter: Iterable) -> float: ...
def group_concat(items: Optional[Any], sep: str = ...) -> Optional[str]: ...
def coalesce(*args: Any) -> Optional[Any]: ...
def distinct(iter: Iterable) -> Dict[Any, Any]: ...
def concat(*args: Any) -> str: ...
def between(x: Any, a: Any, b: Any) -> bool: ...
def is_utf8(encoding: str) -> bool: ...
def pickle_ast(val: Any) -> Any: ...  # TODO: should be io.BytesIO
def unpickle_ast(pickled: Any) -> Any: ...
def copy_ast(tree: Any) -> Any: ...

class HashableDict(dict):
    def __hash__(self): ...
    def __deepcopy__(self, memo: Any): ...
    __setitem__: Any = ...
    __delitem__: Any = ...
    clear: Any = ...
    pop: Any = ...
    popitem: Any = ...
    setdefault: Any = ...
    update: Any = ...

def deref_proxy(value: Any) -> Any: ...
def deduplicate(value: Any, deduplication_cache: Any) -> Any: ...
